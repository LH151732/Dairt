# 算法复杂度与数据结构总览

## 复杂度增长排序

```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)

增长速度可视化:
      n!
     /
    / 2ⁿ
   /
  /  n²
 /   n log n
/    n
log n
1
--------------------------------> n
```

## 数据结构操作复杂度对比

### Array vs Linked List

```
Array:
[1]->[2]->[3]->[4]  // 连续内存
访问: O(1) ↑
插入: O(n) // 需要移动后续元素
删除: O(n) // 需要移动后续元素

Linked List:
[1]-->[2]-->[3]-->[4]  // 分散内存
访问: O(n) // 需要遍历
插入: O(1) // 修改指针即可
删除: O(1) // 修改指针即可
```

## 树结构

### BST (Binary Search Tree)

```
       5
      / \
     3   7    // 左小右大
    / \   \
   1   4   9

平衡状态: O(log n)
       5
      / \
     3   7

不平衡(退化): O(n)
   5
    \
     7
      \
       9
```

## 图遍历

### BFS (Breadth-First Search)

```
层次遍历:
    1         Level 0
   / \
  2   3       Level 1
 / \   \
4   5   6     Level 2

Queue: [1] -> [2,3] -> [4,5,6]
```

### DFS (Depth-First Search)

```
深度优先:
    1
   / \
  2   3      1->2->4->5->3->6
 / \   \
4   5   6

Stack: [1] -> [1,2] -> [1,2,4] ...
```

## 最小生成树

### Prim 算法

```
步骤演示:
   [2]
 2/ |3
1   |   4    选择最小权重边,
 4\ |1 /     逐步扩展
   [3]

Time: O(E log V) (堆优化)
```

### Kruskal 算法

```
步骤演示:
1---2
|  /|
| / |   按边权重排序,
|/  |   依次添加不成环的边
3---4

Time: O(E log E)
```

## 图的存储方式

### 邻接矩阵

```
  1 2 3 4
1 0 1 0 1
2 1 0 1 0
3 0 1 0 1
4 1 0 1 0

空间: O(V²)
适合稠密图
```

### 邻接表

```
1 -> [2,4]
2 -> [1,3]
3 -> [2,4]
4 -> [1,3]

空间: O(V+E)
适合稀疏图
```

## 排序算法

### 冒泡排序 O(n²)

```
[5,3,8,4,6]
[3,5,8,4,6]
[3,5,4,8,6]
...
每次冒泡最大值
```

### 快速排序 O(n log n)

```
[5|3,8,4,6]  pivot=5
[3,4|5|8,6]  分区
[3,4|5|6,8]  递归排序
```

### 归并排序 O(n log n)

```
[5,3,8,4]
[5,3] [8,4]
[3,5] [4,8]    分治
[3,4,5,8]      合并
```

# 常见递归方程及其解

## 基础算法递归方程

| 算法 | 递归方程 | 解 | 说明 |
|------|----------|-----|------|
| 二分查找 | T(n) = T(n/2) + O(1) | O(log n) | 数组上的二分查找 |
| 链表二分查找 | T(n) = T(n/2) + O(n) | O(n) | 需要遍历到中间元素 |
| 归并排序 | T(n) = 2T(n/2) + O(n) | O(n log n) | 分治排序的经典复杂度 |
| Karatsuba整数乘法 | T(n) = 3T(n/2) + O(n) | O(n^(log₂3)) | 约为O(n^1.585) |
| 快速排序(平均) | T(n) = 2T(n/2) + O(n) | O(n log n) | 随机选择轴点 |
| 快速排序(最差) | T(n) = T(n-1) + O(n) | O(n²) | 已排序数组 |

## 常见递归方程通用模式

| 递归方程模式 | 复杂度 | 典型应用 |
|-------------|--------|----------|
| T(n) = 2T(n/2) + O(n) | O(n log n) | 归并排序 |
| T(n) = 2T(n/2) + O(1) | O(n) | 树的遍历 |
| T(n) = T(n/2) + O(1) | O(log n) | 二分查找 |
| T(n) = T(n-1) + O(1) | O(n) | 线性递归 |
| T(n) = T(n-1) + O(n) | O(n²) | 选择排序 |
| T(n) = 2T(n-1) + O(1) | O(2ⁿ) | 斐波那契 |

## 主定理（Master Theorem）应用条件

对于形如 T(n) = aT(n/b) + f(n) 的递归式：

1. 若 f(n) = O(n^c)，且 c < log_b(a)
   - 则 T(n) = O(n^(log_b(a)))

2. 若 f(n) = O(n^c)，且 c = log_b(a)
   - 则 T(n) = O(n^c * log n)

3. 若 f(n) = O(n^c)，且 c > log_b(a)
   - 则 T(n) = O(f(n))

## 分析技巧

1. 递归树法：
```ascii
T(n) = 2T(n/2) + n
            n
          /   \
        n/2   n/2
       /  \   /  \
     n/4 n/4 n/4 n/4
```

2. 展开法：
```
T(n) = T(n-1) + n
     = (T(n-2) + (n-1)) + n
     = (T(n-3) + (n-2)) + (n-1) + n
     = ... 
```